#!/usr/bin/env python3
import argparse
from pathlib import Path

def main():
    global options
    options = get_options()
    vseqs = read_v_sequences(options.vfile)
    analyse_sequence(options.fasta, options.outfile, options.mindist, options.maxdist, options.allowedmismatches,vseqs)


def analyse_sequence(infile,outfile,mindist, maxdist, mismatches, vseqs):
    seq_too_short = 0
    germline_hits = 0
    nov1 = 0
    nov2 = 0
    too_short = 0
    too_long = 0
    hits = 0
    total_seqs = 0

    min_total_len = len(vseqs[0][0]) + len(vseqs[0][1]) + mindist
    min_v2_len = len(vseqs[0][1]) + mindist


    with open(outfile,"wt",encoding="utf8") as out:
        for id,seq in read_fasta(infile):
            total_seqs += 1

            if total_seqs % 1000 == 0:
                print("Processed",total_seqs,"sequences")

            if len(seq) < min_total_len:
                seq_too_short += 1
                continue

            found_v1_hit = False
            for vseq in vseqs:
                # Can we find the VH1 sequence
                lastpos = len(seq)-min_v2_len
                # print(seq, vseq[1], len(seq), len(vseq[1]),lastpos, min_v2_len)
                s1_start = fuzzy_index(seq,vseq[1], mismatches,0,lastpos)
                if s1_start != -1:
                    found_v1_hit = True
                    # Get the end position of the sequence
                    s1_end = s1_start+len(vseq[1])
                    
                    found_v2_hit = False

                    # We first try the other end to see if this
                    # is compatible with being a germline hit
                    if fuzzy_index(seq,vseq[2],mismatches+2,s1_end) != -1:
                        # This is a hit from the same V so it's germline
                        found_v2_hit = True
                        germline_hits += 1
                        break

                    # Now try all of the other ends.
                    for vseq2 in vseqs:
                        s2_start = fuzzy_index(seq,vseq2[2],mismatches,s1_end)

                        if s2_start == -1:
                            continue
                        
                        found_v2_hit = True
                        # If we get a hit it could be a germline one if the V1
                        # sequence is similar enough to the first one we found
                        if fuzzy_index(seq,vseq2[1],mismatches+2) != -1:
                            # Yeah, it's compatible with being germline
                            germline_hits += 1
                            break

                        distance = s2_start - s1_end

                        if distance < mindist:
                            too_short += 1
                            break
                        
                        if distance > maxdist:
                            too_long += 1
                            break

                        # If we get here we've got a hit.
                        hits += 1
                        line = [id,vseq[0],vseq2[0],s1_end, s2_start]
                        print("\t".join([str(x) for x in line]), file=out)
                        break

                    # If we get here we found a v1 but no v2
                    if not found_v2_hit:
                        nov2 += 1
                    break
            # If we get here then we didn't get a hit to any of the V1 sequences
            if not found_v1_hit:
                nov1 += 1

    print("File:", infile)
    print("Total: ",total_seqs)
    print("Hits: ",hits)
    print("Seq too short",seq_too_short)
    print("Germline: ",germline_hits)
    print("Too short: ",too_short)
    print("Too long: ",too_long)
    print("No V1: ",nov1)
    print("No V2: ",nov2)

                        
def read_v_sequences(file):
    print("Reading from ",file)
    vseqs = []
    with open(file,"rt", encoding="utf8") as infh:
        infh.readline()
        for line in infh:
            ig,fromseq,toseq = line.strip().split("\t")
            vseqs.append((ig,fromseq.lower(),toseq.lower()))


    # Let's do some sanity checking - we need to know if there
    # are any duplicated sequences in the set.
    for i in vseqs:
        for j in vseqs:
            if i is j:
                continue
            if i[1] == j[1]:
                if i[0] < j[0]:
                    print("[WARNING] Duplicate V1",i[0],"and",j[0])

            if i[2] == j[2]:
                if i[0] < j[0]:
                    print("[WARNING] Duplicate V2",i[0],"and",j[0])


    return vseqs


def read_fasta(file):
    seq = None
    id = None
    with open(file,"rt",encoding="utf8") as infh:
        for line in infh:
            if line.startswith(">"):
                if seq is not None:
                    yield (id,seq)

                id = line[1:].split()[0].strip()
                seq = ""
            else:
                seq += line.lower().strip()

        if seq is not None:
            yield(id,seq)


def fuzzy_index(longstr,shortstr,allowed_mismatches=0, initialpos=0, lastpos=-1):
    """Find if one string is in another allowing some mismatch"""

    if lastpos == -1:
        lastpos = len(longstr)-len(shortstr)

    if lastpos < 0:
        return -1

    for start in range(initialpos,lastpos+1):
        mismatches = 0
        for pos in range(len(shortstr)):
            if shortstr[pos] != longstr[start+pos]:
                mismatches += 1
                if mismatches > allowed_mismatches:
                    break
        
        if mismatches <= allowed_mismatches:
            return start

    return -1

def get_options():

    parser = argparse.ArgumentParser("Find mis-spliced VDJ Sequences")
    parser.add_argument("fasta",type=str,help="FastA format sequence file to search")
    parser.add_argument("outfile",type=str,help="Output file for hits")
    parser.add_argument("--vfile",type=str,help="File with V sequences to search", default=Path(__file__).parent.joinpath("v_sequences.txt"))
    parser.add_argument("--mindist",type=int, default=0)
    parser.add_argument("--maxdist",type=int, default=20)
    parser.add_argument("--allowedmismatches",type=int, default=1)


    options = parser.parse_args()


    return options


if __name__ == "__main__":
    main()